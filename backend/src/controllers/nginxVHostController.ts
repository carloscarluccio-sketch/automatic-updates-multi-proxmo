import { Response } from 'express';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import prisma from '../config/database';
import { AuthRequest } from '../middlewares/auth';
import logger from '../utils/logger';
import { decrypt } from '../utils/encryption';

const execAsync = promisify(exec);

/**
 * Generate nginx virtual host configuration for a URL mapping
 * POST /api/nginx/generate-vhost/:mapping_id
 */
export const generateVHost = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { mapping_id } = req.params;
    const { role } = req.user!;

    if (role !== 'super_admin') {
      res.status(403).json({ success: false, message: 'Only super admins can generate nginx configurations' });
      return;
    }

    const mapping = await prisma.company_url_mappings.findFirst({
      where: { id: Number(mapping_id) },
      include: { companies: { select: { id: true, name: true } } }
    });

    if (!mapping) {
      res.status(404).json({ success: false, message: 'URL mapping not found' });
      return;
    }

    const domain = mapping.url_pattern;

    if (!mapping.ssl_enabled || !mapping.ssl_certificate || !mapping.ssl_private_key) {
      res.status(400).json({ success: false, message: 'SSL must be enabled and certificate must be configured' });
      return;
    }

    // Create SSL directory
    const sslDir = `/etc/nginx/ssl/${domain}`;
    await execAsync(`mkdir -p ${sslDir}`);

    // Decrypt and write SSL files
    const privateKey = decrypt(mapping.ssl_private_key);
    await fs.writeFile(`${sslDir}/privkey.pem`, privateKey);
    await fs.writeFile(`${sslDir}/fullchain.pem`, mapping.ssl_certificate);
    if (mapping.ssl_chain) {
      await fs.writeFile(`${sslDir}/chain.pem`, mapping.ssl_chain);
    }

    // Set permissions
    await execAsync(`chmod 600 ${sslDir}/privkey.pem`);
    await execAsync(`chmod 644 ${sslDir}/fullchain.pem`);

    // Generate nginx configuration
    const vhostConfig = generateNginxConfig(domain, sslDir);

    // Write configuration file
    const vhostFile = `/etc/nginx/sites-available/${domain}`;
    await fs.writeFile(vhostFile, vhostConfig);

    // Create symlink to enable site
    const enabledLink = `/etc/nginx/sites-enabled/${domain}`;
    try {
      await fs.unlink(enabledLink);
    } catch {
      // Link may not exist
    }
    await execAsync(`ln -s ${vhostFile} ${enabledLink}`);

    // Test nginx configuration
    const { stderr } = await execAsync('nginx -t');
    if (stderr && !stderr.includes('syntax is ok') && !stderr.includes('test is successful')) {
      throw new Error(`Nginx configuration test failed: ${stderr}`);
    }

    // Reload nginx
    await execAsync('systemctl reload nginx');

    // Log activity
    await prisma.activity_logs.create({
      data: {
        user_id: req.user!.id,
        company_id: mapping.company_id,
        activity_type: 'system',
        entity_type: 'url_mapping',
        entity_id: mapping.id,
        action: 'nginx_vhost_generated',
        description: `Nginx virtual host generated for ${domain}`,
        status: 'success',
        metadata: JSON.stringify({ domain, vhost_file: vhostFile }),
        ip_address: req.ip || null
      }
    });

    res.json({
      success: true,
      message: `Nginx virtual host configured for ${domain}`,
      data: {
        domain,
        vhost_file: vhostFile,
        ssl_directory: sslDir
      }
    });
  } catch (error: any) {
    logger.error('Generate nginx vhost error:', error);
    res.status(500).json({ success: false, message: 'Failed to generate nginx vhost', error: error.message });
  }
};

/**
 * Generate nginx virtual host configuration content
 */
function generateNginxConfig(domain: string, sslDir: string): string {
  return `# Nginx configuration for ${domain}
# Generated by Proxmox Multi-Tenant Platform

# HTTP - Redirect to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ${domain} www.${domain};

    # Let's Encrypt webroot for certificate renewal
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/letsencrypt-webroot;
        allow all;
    }

    # Redirect all HTTP to HTTPS
    location / {
        return 301 https://\$host\$request_uri;
    }

    access_log /var/log/nginx/${domain}-access.log;
    error_log /var/log/nginx/${domain}-error.log;
}

# HTTPS - Secure connection
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain} www.${domain};

    # SSL Configuration
    ssl_certificate ${sslDir}/fullchain.pem;
    ssl_certificate_key ${sslDir}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;

    # Proxy settings
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # WebSocket support
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # Console proxy WebSocket
    location /console-proxy {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400;
    }

    access_log /var/log/nginx/${domain}-ssl-access.log;
    error_log /var/log/nginx/${domain}-ssl-error.log;
}
`;
}

/**
 * Remove nginx virtual host configuration
 * DELETE /api/nginx/vhost/:mapping_id
 */
export const removeVHost = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { mapping_id } = req.params;
    const { role } = req.user!;

    if (role !== 'super_admin') {
      res.status(403).json({ success: false, message: 'Only super admins can remove nginx configurations' });
      return;
    }

    const mapping = await prisma.company_url_mappings.findFirst({
      where: { id: Number(mapping_id) }
    });

    if (!mapping) {
      res.status(404).json({ success: false, message: 'URL mapping not found' });
      return;
    }

    const domain = mapping.url_pattern;
    const vhostFile = `/etc/nginx/sites-available/${domain}`;
    const enabledLink = `/etc/nginx/sites-enabled/${domain}`;
    const sslDir = `/etc/nginx/ssl/${domain}`;

    // Remove symlink
    try {
      await fs.unlink(enabledLink);
    } catch {
      // May not exist
    }

    // Remove config file
    try {
      await fs.unlink(vhostFile);
    } catch {
      // May not exist
    }

    // Remove SSL directory
    try {
      await execAsync(`rm -rf ${sslDir}`);
    } catch {
      // May not exist
    }

    // Reload nginx
    await execAsync('systemctl reload nginx');

    // Log activity
    await prisma.activity_logs.create({
      data: {
        user_id: req.user!.id,
        company_id: mapping.company_id,
        activity_type: 'system',
        entity_type: 'url_mapping',
        entity_id: mapping.id,
        action: 'nginx_vhost_removed',
        description: `Nginx virtual host removed for ${domain}`,
        status: 'success',
        metadata: JSON.stringify({ domain }),
        ip_address: req.ip || null
      }
    });

    res.json({
      success: true,
      message: `Nginx virtual host removed for ${domain}`
    });
  } catch (error: any) {
    logger.error('Remove nginx vhost error:', error);
    res.status(500).json({ success: false, message: 'Failed to remove nginx vhost', error: error.message });
  }
};

/**
 * Regenerate all virtual hosts
 * POST /api/nginx/regenerate-all
 */
export const regenerateAllVHosts = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { role } = req.user!;

    if (role !== 'super_admin') {
      res.status(403).json({ success: false, message: 'Only super admins can regenerate all configurations' });
      return;
    }

    const mappings = await prisma.company_url_mappings.findMany({
      where: {
        is_active: true,
        ssl_enabled: true,
        ssl_certificate: { not: null },
        ssl_private_key: { not: null }
      }
    });

    const results: any[] = [];

    for (const mapping of mappings) {
      try {
        const domain = mapping.url_pattern;
        const sslDir = `/etc/nginx/ssl/${domain}`;

        await execAsync(`mkdir -p ${sslDir}`);

        const privateKey = decrypt(mapping.ssl_private_key!);
        await fs.writeFile(`${sslDir}/privkey.pem`, privateKey);
        await fs.writeFile(`${sslDir}/fullchain.pem`, mapping.ssl_certificate!);
        if (mapping.ssl_chain) {
          await fs.writeFile(`${sslDir}/chain.pem`, mapping.ssl_chain);
        }

        await execAsync(`chmod 600 ${sslDir}/privkey.pem`);
        await execAsync(`chmod 644 ${sslDir}/fullchain.pem`);

        const vhostConfig = generateNginxConfig(domain, sslDir);
        const vhostFile = `/etc/nginx/sites-available/${domain}`;
        await fs.writeFile(vhostFile, vhostConfig);

        const enabledLink = `/etc/nginx/sites-enabled/${domain}`;
        try {
          await fs.unlink(enabledLink);
        } catch {}
        await execAsync(`ln -s ${vhostFile} ${enabledLink}`);

        results.push({ domain, status: 'success' });
      } catch (error: any) {
        results.push({ domain: mapping.url_pattern, status: 'failed', error: error.message });
      }
    }

    // Reload nginx once
    await execAsync('systemctl reload nginx');

    // Log activity
    await prisma.activity_logs.create({
      data: {
        user_id: req.user!.id,
        company_id: null,
        activity_type: 'system',
        entity_type: 'nginx',
        entity_id: null,
        action: 'regenerate_all_vhosts',
        description: `Regenerated ${results.length} nginx virtual hosts`,
        status: 'success',
        metadata: JSON.stringify({ results }),
        ip_address: req.ip || null
      }
    });

    res.json({
      success: true,
      message: `Regenerated ${results.length} virtual hosts`,
      data: results
    });
  } catch (error: any) {
    logger.error('Regenerate all vhosts error:', error);
    res.status(500).json({ success: false, message: 'Failed to regenerate vhosts', error: error.message });
  }
};
